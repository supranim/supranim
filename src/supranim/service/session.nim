# Supranim is a simple MVC web framework
# for building web apps & microservices in Nim.
#
# (c) 2024 MIT License | Made by Humans from OpenPeeps
# https://supranim.com | https://github.com/supranim

import std/[options, sequtils]
import pkg/[taskman]
import pkg/supranim/support/[cookie, nanoid]
import pkg/libsodium/[sodium, sodium_sizes]

import ../service
export options, ZSendRecvOptions

newService Session[RouterDealer]:
  ## Built-in Session service using the Router/Dealer ZMQ's pattern.
  ## Compiles to a standalone binary application for handling
  ## authentication sessions and user-based cookies
  port = 55001
  threads = 4
  description = "Default Supranim Session Manager"
  commands = [
    newSession, checkSession, deleteSession,
    setNotification, getNotification,
    setData, mergeData, getData, genCsrf
  ]

  before:
    import std/[times, strutils, tables]

    type
      Notification = string
      UserSessionType = enum
        sessionTypeTemporary
        sessionTypePreserve

      UserSession {.acyclic.} = ref object
        `type`: UserSessionType
        id: string
          # A unique NanoID. This may be regenerated
          # without losing other informations
        backend: CookiesTable = CookiesTable()
          # A backend `CookiesTable`
        client: CookiesTable = CookiesTable()
          # Store a copy of the client-side CookiesTable
        notifications: Table[string, Notification]
          # A temporary seq of flash notification messages
          # that will be displayed in the next Response.
        created: DateTime
          # Creation time
        lastAccess: DateTime
        # device: Device
        hasExpired: bool
          # Marks `UserSession` as expired before deleting it.
          # Expired sessions are cleared by the SessionCleaner
          # in a separate process
        data: JsonNode
        rememberToken: string
          # generated when user checks the `remember me`
          # checkbox to keep it logged in
        nonceToken: string
          # random generated bytes using default
          # libsodium `crypto_box_NONCEBYTES` len
        csrfToken: string
          # a hmac 256 hash

      Sessions = TableRef[string, UserSession]
      
      SessionStorageType = enum
        sessionDBStorage
        sessionFileStorage

      SessionManager = object
        # key: string
        key: string
        keypair: tuple[pk, sk: string] # CryptoBoxPublicKey, CryptoBoxSecretKey
        nonce: string
        storageType: SessionStorageType
        sessions: Sessions = Sessions()

    var Session = SessionManager(nonce: randombytes(crypto_box_NONCEBYTES()))
    Session.keypair = crypto_box_keypair()

    proc newUserSession*(platform, ip: string): UserSession =
      ## Creates a new `UserSession` instance.
      var sessval = newJArray()
      sessval.add(newJString ip)
      sessval.add(newJString platform)
      var id: string
      while true:
        id = nanoid.generate(size = 42)
        if not Session.sessions.hasKey(id):
          break
      # let securedCookie = crypto_box_easy($sessval, Session.nonce, Session.keypair.pk, Session.keypair.sk) 
      let creationTime = now()
      result = UserSession(
        id: id,
        created: creationTime,
        lastAccess: creationTime,
        nonceToken: randombytes(32),
      )
      result.backend["ssid"] = newCookie("ssid", $sessval, creationTime + 60.minutes)
      result.client["ssid"] = newCookie("ssid", result.id, creationTime + 60.minutes)

let defaultDuration = initDuration(minutes=60)
proc cleanup() {.asyncTask: 10.minutes, autorunOnce.} =
  ## Task-based command that clears old session instances. For internal-use only
  let nowTime = now()
  var i = 0
  let keys = Session.sessions.keys.toSeq
  while i <= keys.high:
    let uss = Session.sessions[keys[i]]
    if (nowTime - uss.created >= defaultDuration):
      if nowTime - uss.lastAccess <= defaultDuration:
        displayInfo("Extend session")
      else:
        displayInfo("Expired session " & uss.id)
        Session.sessions.del(uss.id)
        freemem(uss)
    inc i

proc newSession(clientBrowser, clientIp, currentPath: string) {.command.} = 
  ## Create a new `UserSession` using `clientBrowser`, `clientIp` and `currentPath`
  let uss = newUserSession(clientBrowser, clientIp)
  let id = uss.client["ssid"].getValue
  Session.sessions[id] = uss
  uss.csrfToken = crypto_auth_hmacsha256(currentPath, uss.nonceToken)
  send($uss.client["ssid"])

proc checkSession(clientId, clientIp, clientPlatform: string) {.command.} =
  ## Check if Session contains an active
  ## `ssid` based on `clientId`
  if Session.sessions.hasKey(clientId):
    let uss = Session.sessions[clientId]
    if likely(uss.data != nil):
      if uss.data["ip"].getStr == clientIp and
         uss.data["platform"].getStr == clientPlatform:
        uss.lastAccess = now()
        send($uss.client["ssid"])
      else: discard
  empty()

proc deleteSession(clientId: string) {.command.} =
  ## Command to delete a session by `clientId`
  if likely(Session.sessions.hasKey(clientId)):
    var clientCookie: ref Cookie = Session.sessions[clientId].client["ssid"]
    clientCookie.expires()
    server.send($clientCookie)
    Session.sessions.del(clientId)
    freemem(clientCookie)
  else:
    empty()

proc setNotification(clientId, key, msg: string) {.command.} =
  ## Command to store a new flash bag notification message
  ## for `clientId` using `key` and `msg`
  if likely(Session.sessions.hasKey(clientId)):
    Session.sessions[clientId].notifications[key] = msg
  empty()

proc getNotification(clientId, key: string) {.command.} =
  ## Command to retrieve a flash bag notification message
  ## by `clientId` and `key`
  if Session.sessions.hasKey(clientId):
    if Session.sessions[clientId].notifications.hasKey(key):
      server.send(Session.sessions[clientId].notifications[key])
      Session.sessions[clientId].notifications.del(key) # delete the message
      return
  empty()

proc setData(clientId: string, data: JsonNode) {.command.} =
  ## Command to set JSON data for a specific `UserSession`
  ## by `clientId`
  if Session.sessions.hasKey(clientId):
    Session.sessions[clientId].data = data
  empty()

proc mergeData(clientId, key: string, data: JsonNode) {.command.} =
  ## Merge a new JSON `data` to a specific `UserSession`
  ## **Important** This proc can overwrite existing data from `key`
  ## in case `key` exists.
  if Session.sessions.hasKey(clientId):
    Session.sessions[clientId].data[key] = data
  empty()

proc getData(clientId: string) {.command.} =
  ## Get JSON data of the current `UserSession`
  if Session.sessions.hasKey(clientId):
    send(toJson(Session.sessions[clientId].data))
  empty()

proc genCsrf(clientId: string) {.command.} =
  ## Get a CSRF token
  if Session.sessions.hasKey(clientId):
    send(bin2hex(Session.sessions[clientId].csrfToken))
  # empty()

runService do:
  # Service Provider API for the main application
  import std/json
  from std/strutils import unescape
  from ../core/request import Request, getPlatform, getIp, getUriPath
  from ../core/response import Response, addHeader
  from ../controller import getClientId, getClientCookie, getUriPath
  
  export cookie, json

  type
    SessionError* = object of CatchableError

  proc initUserSession*(req: Request, res: var Response) = 
    ## Initializes a new `UserSession` then inject a
    ## `set-cookie` header for the upcoming `res` Response. 
    let platform =
      if req.getPlatform.len > 0:
        unescape(req.getPlatform)
      else: ""
    let someSession = newSession(platform, req.getIp, req.getUriPath)
    if someSession.isSome:
      let ssid = someSession.get()[0]
      res.addHeader("set-cookie", ssid)
    else:
      raise newException(SessionError, "Could not create a new Session")
  
  proc getCsrf*(req: Request): string =
    let clientCookie: ref Cookie = req.getClientCookie()
    if clientCookie != nil:
      let
        someCsrf = genCsrf(clientCookie.getValue())
      if someCsrf.isSome:
        return someCsrf.get()[0]

  template initSession*(needRefresh = false) =
    ## A template for creating new `UserSession` instances.
    ## This template can be used inside a `controller`/`middleware` context
    block:
      let clientCookie: ref Cookie = req.getClientCookie()
      if clientCookie != nil:
        let clientId = clientCookie.getValue()
        let status = checkSession(clientId, req.getIp, req.getPlatform)
        if needRefresh:
          deleteSession(clientId)
          try:
            initUserSession(req, res)
          except SessionError as e:
            render("errors.5xx", "public", code = HttpCode(500))
        elif status.isNone:
          try:
            initUserSession(req, res)
          except SessionError:
            render("errors.5xx", "public", code = HttpCode(500))
        else: discard # reuse session id 
      else:
        try:
          initUserSession(req, res)
        except SessionError as e:
          render("errors.5xx", "public", code = HttpCode(500))

  template delete* =
    ## Destroys the current `UserSession`.
    ## Can be used inside a `controller`/`middleware` context
    block:
      let id = req.getClientID
      if likely(id.isSome):
        let someCookie = deleteSession(id.get())
        if likely(someCookie.isSome):
          res.addHeader("set-cookie", someCookie.get()[0])

  template notify*(msg: string) = 
    ## A template for creating a new
    ## session-based flash bag message.
    block:
      let id = req.getClientID()
      if likely(id.isSome):
        setNotification(id.get, req.getUriPath, msg)

  template getSessionData*: untyped =
    ## Get JSON data from the current `UserSession`
    ## Can be used inside a `controller`/`middleware` context
    block:
      let id = req.getClientId()
      var data: JsonNode
      if likely(id.isSome):
        let x = session.getData(id.get)
        if x.isSome:
          try:
            data = jsony.fromJson(x.get()[0])
          except jsony.JsonError:
            discard
      data

  proc getNotify*(req: Request): Option[seq[string]] =
    ## Returns a seq[string] containing flash bag
    ## messages set from the previous request
    let id = req.getClientID()
    if likely(id.isSome):
      result = getNotification(id.get(), req.getUriPath())
